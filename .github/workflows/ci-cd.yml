name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  KUBERNETES_VERSION: '1.28'
  ISTIO_VERSION: '1.20.0'

jobs:
  validate:
    name: Validate Manifests
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBERNETES_VERSION }}

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Validate Kubernetes manifests
      run: |
        echo "Validating Kubernetes manifests..."
        find . -name "*.yaml" -o -name "*.yml" | grep -v node_modules | while read file; do
          echo "Validating $file"
          kubectl --dry-run=client apply -f "$file" || echo "Validation failed for $file"
        done

    - name: Validate Helm charts
      run: |
        echo "Validating Helm charts..."
        helm lint observability/manifests/prometheus-values.yaml || true
        helm lint observability/manifests/jaeger-values.yaml || true
        helm lint security/manifests/falco-values.yaml || true

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'

  test-cluster:
    name: Test Cluster Setup
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBERNETES_VERSION }}

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Create kind cluster
      uses: helm/kind-action@v1.8.0
      with:
        cluster_name: test-cluster
        config: |
          kind: Cluster
          apiVersion: kind.x-k8s.io/v1alpha4
          nodes:
          - role: control-plane
            kubeadmConfigPatches:
            - |
              kind: InitConfiguration
              nodeRegistration:
                kubeletExtraArgs:
                  node-labels: "ingress-ready=true"
            extraPortMappings:
            - containerPort: 80
              hostPort: 80
              protocol: TCP
            - containerPort: 443
              hostPort: 443
              protocol: TCP

    - name: Install Istio
      run: |
        curl -L https://istio.io/downloadIstio | sh -
        export PATH=$PWD/istio-*/bin:$PATH
        istioctl install --set values.defaultRevision=default -y

    - name: Deploy test manifests
      run: |
        kubectl apply -f manifests/namespace.yaml
        kubectl apply -f microservices/manifests/ -R

    - name: Wait for deployments
      run: |
        kubectl wait --for=condition=available --timeout=300s deployment/frontend -n microservices
        kubectl wait --for=condition=available --timeout=300s deployment/backend -n microservices

    - name: Test services
      run: |
        kubectl get pods -n microservices
        kubectl get svc -n microservices

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [validate, security-scan]
    if: github.ref == 'refs/heads/develop'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to staging
      run: |
        echo "Deploying to staging environment..."
        # Add staging deployment logic here

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [validate, security-scan, test-cluster]
    if: github.ref == 'refs/heads/main'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to production
      run: |
        echo "Deploying to production environment..."
        # Add production deployment logic here

  notify:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()
    steps:
    - name: Notify success
      if: needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success'
      run: |
        echo "Deployment successful!"

    - name: Notify failure
      if: needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure'
      run: |
        echo "Deployment failed!"
